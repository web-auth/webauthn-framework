Webauthn Symfony Bundle
=======================

# Installation

Install the bundle with Composer:

```sh
composer require web-auth/webauthn-symfony-bundle
```

If you are using Symfony Flex then the bundle will automatically be installed.
Otherwise you need to add it in your `AppKernel.php` file:

```php
<?php
// app/AppKernel.php

public function registerBundles()
{
    $bundles = [
        // ...
        new Webauthn\Bundle\WebauthnBundle(),
    ];
}
```

# Create Classes

This bundle needs classes and services to work:

* The credential object: it represents a credential from a security device,
* The Public Key Credential Source Repository: it will manage all credential sources

## Public Key Credential Source

### The Entity

A Public Key Credential Source objects contains all the necessary information corresponds related to attested data received from a device.
Hereafter an example using Doctrine ORM.

This entity can be enhanced and may also have a name, description, last usage timestamp or any other application specific fields to ease the management of this credential by the user or the administrator of your application.

Please note that no relationship between the credential and your user is present in this example. You may need to add such information (`OneToMany`/`ManyToOne` relationship).

This bundle also provides Doctrine types to ease the integration with your favorite ORM:

* Class `Webauthn\AttestedCredentialData` => Doctrine Type `attested_credential_data`
* Class `Webauthn\Base64BinaryDataType` => Doctrine Type `base64`
* Class `Webauthn\PublicKeyCredentialDescriptor` => Doctrine Type `public_key_credential_descriptor`
* Class `Webauthn\PublicKeyCredentialDescriptorCollection` => Doctrine Type `public_key_credential_descriptor_collection`

```php
<?php

declare(strict_types=1);

namespace App\Entity;

use Doctrine\ORM\Mapping as ORM;
use Webauthn\PublicKeyCredentialSource as BasePublicKeyCredentialSource;

/**
 * @ORM\Table(name="public_key_credential_sources")
 * @ORM\Entity(repositoryClass="App\Repository\PublicKeyCredentialSourceRepository")
 */
class PublicKeyCredentialSource extends BasePublicKeyCredentialSource
{
    /**
     * @var string
     * @ORM\Id
     * @ORM\GeneratedValue
     * @ORM\Column(type="integer")
     */
    private $id;

    public function getId(): string
    {
        return $this->id;
    }
}
```

### The Repository

The repository will save and retrieve the credentials on-demand. It must implement `Webauthn\PublicKeyCredentialSourceRepository`.
To ease the integration into your application, the bundle provides a concrete class that uses Doctrine you can extend.

In this following example, we extend that class and add a method to get all credentials for a specific user handle.

Feel free to add your own methods.

```php
<?php

declare(strict_types=1);

namespace App\Repository;

use App\Entity\PublicKeyCredentialSource;
use Doctrine\Common\Persistence\ManagerRegistry;
use Webauthn\PublicKeyCredentialUserEntity;
use Webauthn\Bundle\Repository\PublicKeyCredentialSourceRepository as BasePublicKeyCredentialSourceRepository;

final class PublicKeyCredentialSourceRepository extends BasePublicKeyCredentialSourceRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, PublicKeyCredentialSource::class);
    }

    /**
     * @return PublicKeyCredentialSource[]
     */
    public function allForUser(PublicKeyCredentialUserEntity $user): array
    {
        $qb = $this->getEntityManager()->createQueryBuilder();

        return $qb->select('c')
            ->from($this->getClass(), 'c')
            ->where('c.userHandle = :user_handle')
            ->setParameter(':user_handle', $user->getId())
            ->getQuery()
            ->execute()
        ;
    }
}
```

This repository should be declared as a Symfony service.

```yaml
services:
    App\Repository\PublicKeyCredentialSourceRepository: ~

```

## Public Key Credential User Entity

### The Entity

The user entity is the user in the Webauthn scope.
This entity must extend the class `Webauthn\PublicKeyCredentialUserEntity`.

In a Symfony application context, you usually have to manage several user entities. Thus, in the following example,
the user entity class will extend the required calls and implements the interface provided by the Symfony Security component.

Feel free to add the necessary setters as well as other fields you need (creation date, last update at…).

**Please note that the ID of the user IS NOT generated by Doctrine and must be a string.**
We highly recommend you to use UUIDs.

```php
<?php

declare(strict_types=1);

namespace App\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Bridge\Doctrine\Validator\Constraints\UniqueEntity;
use Symfony\Component\Security\Core\User\UserInterface;
use Symfony\Component\Validator\Constraints as Assert;
use Webauthn\PublicKeyCredentialUserEntity;

/**
 * @ORM\Table(name="users")
 * @ORM\Entity(repositoryClass="App\Repository\UserRepository")
 * @UniqueEntity("name")
 */
class User extends PublicKeyCredentialUserEntity implements UserInterface
{
    /**
     * @ORM\Id
     * @ORM\Column(type="string", length=255)
     */
    protected $id;

    /**
     * @ORM\Column(type="string", length=255)
     * @Assert\Length(max = 100)
     */
    protected $name;

    /**
     * @ORM\Column(type="string", length=255)
     * @Assert\Length(max = 100)
     */
    protected $displayName;

    /**
     * @ORM\Column(type="array")
     */
    protected $roles;

    /**
     * @var PublicKeyCredentialSource[]
     * @ORM\ManyToMany(targetEntity="App\Entity\PublicKeyCredentialSource")
     * @ORM\JoinTable(name="users_user_handles",
     *      joinColumns={@ORM\JoinColumn(name="user_id", referencedColumnName="id")},
     *      inverseJoinColumns={@ORM\JoinColumn(name="user_handle", referencedColumnName="id", unique=true)}
     *      )
     */
    protected $publicKeyCredentialSources;

    public function __construct(string $id, string $name, string $displayName, array $roles)
    {
        parent::__construct($name, $id, $displayName);
        $this->roles = $roles;
        $this->publicKeyCredentialSources = new ArrayCollection();
    }

    public function getRoles(): array
    {
        return array_unique($this->roles + ['ROLE_USER']);
    }

    public function getPassword(): void
    {
    }

    public function getSalt(): void
    {
    }

    public function getUsername(): ?string
    {
        return $this->name;
    }

    public function eraseCredentials(): void
    {
    }

    /**
     * @return PublicKeyCredentialSource[]
     */
    public function getPublicKeyCredentialSources(): array
    {
        return $this->publicKeyCredentialSources->getValues();
    }
}
```

### The Repository

The repository must implement the interface `Webauthn\Bundle\Repository\PublicKeyCredentialUserEntityRepository`.
The following example uses Doctrine to create, persist or perform queries using the User objects created above.

```php
<?php

declare(strict_types=1);

namespace App\Repository;

use App\Entity\User;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepositoryInterface;
use Doctrine\Common\Persistence\ManagerRegistry;
use Doctrine\ORM\EntityManagerInterface;
use LogicException;
use Webauthn\PublicKeyCredentialUserEntity;
use Webauthn\Bundle\Repository\PublicKeyCredentialUserEntityRepository as BasePublicKeyCredentialUserEntityRepository;

final class UserRepository implements ServiceEntityRepositoryInterface, BasePublicKeyCredentialUserEntityRepository
{
    /**
     * @var EntityManagerInterface
     */
    private $manager;

    public function __construct(ManagerRegistry $registry)
    {
        $manager = $registry->getManagerForClass(User::class);

        if (null === $manager) {
            throw new LogicException(sprintf(
                'Could not find the entity manager for class "%s". Check your Doctrine configuration to make sure it is configured to load this entity’s metadata.',
                User::class
            ));
        }

        $this->manager = $manager;
    }

    public function save(User $user): void
    {
        $this->manager->persist($user);
        $this->manager->flush();
    }

    public function findOneByUsername(string $username): ?User
    {
        $qb = $this->manager->createQueryBuilder();

        return $qb->select('u')
            ->from(User::class, 'u')
            ->where('u.name = :name')
            ->setParameter(':name', $username)
            ->setMaxResults(1)
            ->getQuery()
            ->getOneOrNullResult()
        ;
    }

    public function findOneByUserHandle(string $userHandle): ?User
    {
        $qb = $this->manager->createQueryBuilder();

        return $qb->select('u')
            ->from(User::class, 'u')
            ->where('u.user_handle = :user_handle')
            ->setParameter(':user_handle', $userHandle)
            ->setMaxResults(1)
            ->getQuery()
            ->getOneOrNullResult()
        ;
    }
    
    public function createUserEntity(string $username,string $displayName,?string $icon) : PublicKeyCredentialUserEntity
    {
        return new User($username,$displayName,$icon);
    }
    
    public function saveUserEntity(PublicKeyCredentialUserEntity $userEntity) : void
    {
        $this->manager->persist($userEntity);
        $this->manager->flush();
    }
}
```

This repository should be declared as a Symfony service.

```yaml
services:
    App\Repository\UserRepository: ~

```

# Configuration

This is an example of the minimal configuration for the bundle.

```yaml
webauthn:
    credential_repository: 'App\Repository\PublicKeyCredentialSourceRepository'
    user_repository: 'App\Repository\UserRepository'
```

# Available Services

The bundle allows you to use the following public services:

* `Webauthn\PublicKeyCredentialLoader`
* `Webauthn\AuthenticatorAttestationResponseValidator`
* `Webauthn\AuthenticatorAssertionResponseValidator`
* `Webauthn\Bundle\Service\PublicKeyCredentialCreationOptionsFactory`
* `Webauthn\Bundle\Service\PublicKeyCredentialRequestOptionsFactory`

These services can be injected or retrieved from the Symfony container (`$container->get(PublicKeyCredentialLoader::class)`).
They will help you to register new credentials and authenticate users.

The usage of these services is described in the following sections.

# Creation/Request Profiles

To interact with the security devices, you have to create a challenge.
This challenge comes with options depending on the context (creation or assertion request).

This step is described [here](../webauthn/PublicKeyCredentialCreation.md) and [here](../webauthn/PublicKeyCredentialRequest.md).
Because the creation of these requests may be too verbose, you can configure profiles that will help you a lot.

You can create several profiles depending on the use cases. For example, an administration section may require security devices
attached on the platform with specific extensions and a resident key.

## Creation Profile

Creation profiles are used when you register a new device.
This is needed when a user account is created or when the user wants to associate another device to its account.

With the following configuration, a profile named `profile1` will be created:

```yaml
webauthn:
    …
    creation_profiles:
        profile1: # Unique name of the profile
            public_key_credential_parameters: # Mandatory. Algorithms ES256 and RS256 should be included. In order of preference
                - !php/const Cose\Algorithms::COSE_ALGORITHM_ES256
                - !php/const Cose\Algorithms::COSE_ALGORITHM_RS256
            rp: # Relying Praty information
                name: 'My application' # Name of the relying party
                id: 'demo.webauth.app' # ID of the relying party (i.e. the domain)
                icon: 'https://demo.webauth.app/assets/app.png' # Optional icon. May be ignored by the browser
            challenge_length: 16 # Length of the challenge (in bytes).
            timeout: 30000 # May be ignored by the browser
            authenticator_selection_criteria: # Optional. See https://www.w3.org/TR/webauthn/#authenticatorSelection
                attachment_mode: !php/const Webauthn\AuthenticatorSelectionCriteria::AUTHENTICATOR_ATTACHMENT_PLATFORM
                require_resident_key: true
                user_verification: !php/const Webauthn\AuthenticatorSelectionCriteria::USER_VERIFICATION_REQUIREMENT_REQUIRED
            attestation_conveyance: !php/const Webauthn\PublicKeyCredentialCreationOptions::ATTESTATION_CONVEYANCE_PREFERENCE_DIRECT
            extensions: # Optional. See https://www.w3.org/TR/webauthn/#extensions
                exts: true
                uvi: true
```

Then you will be able to create `PublicKeyCredentialCreationOptions` using the dedicated factory and that profile name.
Let say you want to register a new user account and ask that user to use its security device.

```php
<?php

use Webauthn\Bundle\Service\PublicKeyCredentialCreationOptionsFactory;
use Webauthn\Bundle\Repository\PublicKeyCredentialUserEntityRepository;

/** @var PublicKeyCredentialUserEntityRepository $userRepository */
$userRepository = $this->container->get(UserRepository::class);

/** @var PublicKeyCredentialCreationOptionsFactory $factory */
$factory = $this->container->get(UserRepository::class);

$userEntity = $userRepository->createUserEntity('username', 'John Doe');

$publicKeyCredentialCreationOptions = $factory->create('profile1', $userEntity);
```

You can now render the variable `$publicKeyCredentialCreationOptions`
as a JSON object and interact with a security device the same way [as here](../webauthn/PublicKeyCredentialCreation.md).

## Request Profile

Request profiles are similar to the Creation Profile, but with this profile your application already knows the devices and wants to authenticate a user.
With the following configuration, a profile named `foo` will be created:

```yaml
webauthn:
    …
    request_profiles:
        foo:
            extensions:
                foo: 'bar'
            rp_id: 'demo.webauth.app'
            challenge_length: 16
            timeout: 30000
            user_verification: !php/const Webauthn\AuthenticatorSelectionCriteria::USER_VERIFICATION_REQUIREMENT_REQUIRED
```

Then you will be able to create `PublicKeyCredentialRequestOptionsFactory` using the dedicated factory and that profile name.
Let say you want to register a new user account and ask that user to use its security device.

```php
<?php

use Webauthn\Bundle\Service\PublicKeyCredentialRequestOptionsFactory;
use Webauthn\Bundle\Repository\PublicKeyCredentialUserEntityRepository;
use Webauthn\Bundle\Repository\PublicKeyCredentialSourceRepository;

/** @var PublicKeyCredentialUserEntityRepository $userRepository */
$userRepository = $this->container->get(UserRepository::class);

/** @var PublicKeyCredentialSourceRepository $credentialRepository */
$credentialRepository = $this->container->get(PublicKeyCredentialSourceRepository::class);

/** @var PublicKeyCredentialRequestOptionsFactory $factory */
$factory = $this->container->get(UserRepository::class);

// We retrieve the user entity (throw an exception if not found)
$userEntity = $userRepository->findOneByUsername('username');

// We get the associated credential list
$allowedCredentials = $credentialRepository->findAllForUserEntity($userEntity);


// The PublicKeyCredentialRequestOptions object is created for that user
$publicKeyCredentialRequestOptions = $factory->create('profile1', $userEntity);
```

You can now render the variable `$publicKeyCredentialRequestOptions`
as a JSON object and interact with a security device the same way [as here](../webauthn/PublicKeyCredentialRequest.md).

# Android SafetyNet Support

This attestation format is highly recommended. The users will be able to use their Android device as a security device.
You MUST have an API key from your Google APIs Console to use that format. Please refer to [the official documentation](https://developer.android.com/training/safetynet/attestation) to get that API key. 

Additionally and because your Symfony application will communicate with the SafetyNet servers, you must install an HTTP Client.
The library uses HttPlug. Please refer to [the official documentation](http://docs.php-http.org/en/latest/integrations/symfony-bundle.html) for the integration into your Symfony application.

When you are ready, you can configure this bundle to enable that feature:

```yaml
webauthn:
    …
    android_safetynet:
        enabled: true
        api_key: '%env(SAFETYNET_API_KEY)%'
        http_client: 'httplug.client.safetynet'
```

# Token Binding Handler

The [RFC8471](https://tools.ietf.org/html/rfc8471) adds a security feature to bind the response from a security device with the current TLS session. With this feature, it is more complicated for an attacker to perform replay attacks.

As this feature is not fully supported by browsers and servers and implementations are very rare, a Token Binding Handler is present in the library and this bundle.
At the moment this feature is not supported by the library, but using this handler, you can decide the strategy to adopt if token binding is present in the security device responses.

Available handlers (Symfony services):

* Ignore: use `Webauthn\TokenBinding\IgnoreTokenBindingHandler` to ignore the Token Binding
* Error (default): use `Webauthn\TokenBinding\TokenBindingNotSupportedHandler` and throw an exception

See also [#2](https://github.com/web-auth/webauthn-framework/issues/2) for more information.

Configuration example:

```yaml
#...
webauthn:
    …
    token_binding_support_handler: 'Webauthn\TokenBinding\IgnoreTokenBindingHandler' # Default is 'Webauthn\TokenBinding\TokenBindingNotSupportedHandler'
```
